"""Unit tests for scripts/generate_diagrams.py."""

from __future__ import annotations

from pathlib import Path

import pytest
from _pytest.capture import CaptureFixture
from _pytest.monkeypatch import MonkeyPatch

from scripts import generate_diagrams as gen

# Constants for test assertions
PUML_NOT_AVAILABLE_MESSAGE = "could not generate PUML"


def _mock_pyreverse_none(_path: Path, _package: str) -> dict[str, str] | None:
    """Mock pyreverse not available."""
    return None


def _mock_pyreverse_success(_path: Path, _package: str) -> dict[str, str] | None:
    """Mock pyreverse producing deterministic PUML."""
    return {"classes": "@startuml\nclass Fake\n@enduml\n", "packages": "@startuml\npackage fake\n@enduml\n"}


@pytest.fixture
def fake_package(tmp_path: Path) -> Path:
    """Create a fake Python package for testing."""
    src = tmp_path / "src"
    pkg = src / "fakepkg"
    pkg.mkdir(parents=True)
    (pkg / "__init__.py").write_text("# fake pkg")
    return pkg


@pytest.fixture
def output_puml_dir(tmp_path: Path) -> Path:
    """Create output directory for PUML files."""
    return tmp_path / "docs" / "diagrams" / "puml"


@pytest.fixture
def missing_package(tmp_path: Path) -> Path:
    """Create a fake missing package for testing."""
    src = tmp_path / "src"
    pkg = src / "missingpkg"
    pkg.mkdir(parents=True)
    (pkg / "__init__.py").write_text("# missing pkg")
    return pkg


@pytest.fixture
def missing_output_puml_dir(tmp_path: Path) -> Path:
    """Create output directory for missing package PUML files."""
    return tmp_path / "docs" / "diagrams" / "puml"


def _fake_generate_class_puml(_src_path: Path, _package: str, _out_puml: Path) -> bool:
    """Fake implementation that simulates failing PUML generation."""
    return False


def _fake_generate_pydeps_svg(_package: str, _out_svg: Path, _max_bacon: int = 2) -> bool:
    """Fake implementation that simulates successful pydeps SVG generation."""
    return True


def test_generate_class_puml_api_and_files(fake_package: Path, output_puml_dir: Path, monkeypatch: MonkeyPatch) -> None:
    """Test that PUML files are generated when pyreverse API is available."""
    monkeypatch.setattr(gen, "_try_pyreverse", _mock_pyreverse_success)
    # Ensure plantuml rendering is not attempted in this unit test;
    # we only assert that the PUML file is created.
    made = gen.generate_class_puml(fake_package, "fakepkg", output_puml_dir)
    assert made, "PUML file should be generated successfully"
    classes_file = output_puml_dir / "classes_fakepkg.puml"
    assert classes_file.exists(), "Classes PUML file should exist on disk"
    assert "class Fake" in classes_file.read_text(), "PUML content should contain expected class"


def test_generate_class_puml_missing_tools(
    missing_package: Path, missing_output_puml_dir: Path, monkeypatch: MonkeyPatch, capsys: CaptureFixture[str]
) -> None:
    """Test behaviour when pyreverse tools are not available."""
    # Simulate pyreverse entrypoints not being available.
    monkeypatch.setattr(gen, "_try_pyreverse", _mock_pyreverse_none)

    made = gen.generate_class_puml(missing_package, "missingpkg", missing_output_puml_dir)
    assert not made, "Should return False when tools are not available"
    captured = capsys.readouterr()
    assert PUML_NOT_AVAILABLE_MESSAGE in captured.out, "Should warn about missing tools"


def test_generate_class_puml_pyreverse_success(
    fake_package: Path, output_puml_dir: Path, monkeypatch: MonkeyPatch
) -> None:
    """When pyreverse is available it should be used and write a PUML file."""
    monkeypatch.setattr(gen, "_try_pyreverse", _mock_pyreverse_success)
    made = gen.generate_class_puml(fake_package, "fakepkg", output_puml_dir)
    assert made, "PUML file should be generated by pyreverse"
    classes_file = output_puml_dir / "classes_fakepkg.puml"
    assert classes_file.exists(), "Classes PUML file should exist on disk"
    assert "class Fake" in classes_file.read_text(), "PUML content should contain expected class"


def test_generate_all_diagrams_strict_mode(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
    """Test strict mode behaviour when no packages are found."""
    # No actual packages discovered and strict mode -> exit_code should be 1
    monkeypatch.setenv("STRICT_DIAGRAMS", "1")
    rc, _ = gen.generate_all_diagrams(src_root=tmp_path / "src_empty")
    assert rc == 1, "Should return exit code 1 in strict mode when no packages found"

    # When strict is off, missing packages return 0 but no results
    monkeypatch.delenv("STRICT_DIAGRAMS", raising=False)
    rc2, _ = gen.generate_all_diagrams(src_root=tmp_path / "src_empty")
    assert rc2 == 0, "Should return exit code 0 in non-strict mode"


def test_generate_all_diagrams_strict_mode_partial_failure(monkeypatch: MonkeyPatch) -> None:
    """In strict mode any missing artifact for a package should make the.

    diagrams generator fail (non-zero exit code).
    """
    monkeypatch.setenv("STRICT_DIAGRAMS", "1")

    # Simulate puml generation failing but pydeps succeeding for the package
    monkeypatch.setattr(gen, "generate_class_puml", _fake_generate_class_puml)
    monkeypatch.setattr(gen, "generate_pydeps_svg", _fake_generate_pydeps_svg)

    rc, results = gen.generate_all_diagrams(packages=["fakepkg"])
    assert rc == 1, "Strict mode should return non-zero when any artifact fails"
    assert "fakepkg" in results


def test_generate_all_diagrams_non_strict_partial_failure(monkeypatch: MonkeyPatch) -> None:
    """When strict mode is off partial failures should not fail the.

    overall diagrams generation (non-zero only when nothing created).
    """
    monkeypatch.delenv("STRICT_DIAGRAMS", raising=False)
    monkeypatch.setattr(gen, "generate_class_puml", _fake_generate_class_puml)
    monkeypatch.setattr(gen, "generate_pydeps_svg", _fake_generate_pydeps_svg)

    rc, _ = gen.generate_all_diagrams(packages=["fakepkg"])
    assert rc == 0, "Non-strict mode should not fail on partial artifact failures"
